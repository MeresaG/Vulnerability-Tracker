const { response } = require('express');
const mongoose = require('mongoose');
const Vulnerability = mongoose.model(process.env.VULNERABILITY_MODEL);

const initResponse = function() {
    const response = {
        status : process.env.HTTP_STATUS_OK,
        message : {} 
    }
    return response;
}

const _saveRefactory = function(res, documentToUpdate, response) {
    documentToUpdate.save(function(err, updatedDcoument) {
        if(err) {
            response.status = process.env.HTTP_STATUS_INTERNAL_ERROR;
            response.message = err;
        }else {
            response.status = process.env.HTTP_STATUS_CREATED;
            response.message = updatedDcoument;
        }
        return res.status(response.status).json(response.message)
    })
}


const _updateVulnerability = function(req, res, updateVulnerabilityCallback) {
    const vulnerabilityId = req.params.vulnerabilityId;
    const response = initResponse();
    //check if vulnerabilityId is valid
    
    if(!mongoose.isValidObjectId(vulnerabilityId)) {
        console.log("invalid Id");
        response.status = process.env.HTTP_STATUS_NOTFOUND;
        response.message = {message : "Invalid vulnerabilityId"}
        return res.status(response.status).json(response.message)
    }

    Vulnerability.findById(vulnerabilityId).exec(function(err, vulnerability) {
        if(err) {
            console.log("Error finding vulnerability");
            response.status = process.env.HTTP_STATUS_INTERNAL_ERROR;
            response.message = err;
        }else if(!vulnerability) {
            console.log("vulnerability is null");
            response.status = process.env.HTTP_STATUS_NOTFOUND;
            response.message = {message : "vulnerability with given Id not found"};
        }
        if(vulnerability) {
            updateVulnerabilityCallback(req, res, vulnerability, response);
        }
        else {
            return res.status(response.status).json(response.message);
        }
    })

}

const getOneVulnerability = function(req, res) {
    console.log("Get One Vulnerability Controller called");
    const vulnerabilityId= req.params.vulnerabilityId;
    const response = initResponse();
    //check if gameId is valid
    
    if(!mongoose.isValidObjectId(vulnerabilityId)) {
            console.log("invalid Id");
            response.status = process.env.HTTP_STATUS_NOTFOUND;
            response.message = {message : "Invalid vulnerabilityId"}
            return res.status(response.status).json(response.message)
    }

    Vulnerability.findById(vulnerabilityId).exec(function(err, vulnerability) {
        if(err) {
            console.log("Error finding vulnerability");
            response.status = process.env.HTTP_STATUS_INTERNAL_ERROR;
            response.message = {error : err};

        } 
        else {
            if(vulnerability) {
                console.log("Found Vulnerability");
                response.status = process.env.HTTP_STATUS_OK;
                response.message = vulnerability;
            }
            else {
                console.log("vulnerability is null");
                response.status = process.env.HTTP_STATUS_NOTFOUND;
                response.message = {message : "Vulnerability with given Id not found"};
            }
        }

        return res.status(response.status).json(response.message);
        
        });
}

const getAllVulnerabilities = function(req, res) {
    console.log("Get All Vulnerabilities Controller called");
    const response = initResponse()
    let offset = process.env.OFFSET;
    let count = process.env.COUNT;
    if(req.query && req.query.offset) {
        offset = parseInt(req.query.offset, 10);
    }
    if(req.query && req.query.count) {
        count = parseInt(req.query.count, 10);
        
    }
    if(isNaN(offset) || isNaN(count)) {
        console.log("Offset or Count is not a number");
        response.status = process.env.HTTP_STATUS_NOTFOUND;
        response.message = {message : "Offset and Count must be  digits"};
        
    }
    if(response.status !== process.env.HTTP_STATUS_OK) {
        return res.status(response.status).json(response.message);
    }
     else {
        count = count > 10 ? 10 : count;
        Vulnerability.find().skip(offset).limit(count).exec(function(err, vulnerabilities) {
            if(err) {
                response.status = process.env.HTTP_STATUS_INTERNAL_ERROR;
                response.message = err;

            }
            else {
                console.log("Found Vulnerabilities");
                response.status = process.env.HTTP_STATUS_OK;
                response.message = vulnerabilities;
            }
            return res.status(response.status).json(response.message)
            
            });
    }
}

const AddOneVulnerability = function(req, res) {
    console.log("Add One Vulnerability Controller called");
    const response = initResponse();

    const newVulnerability = {

        vulnerabilityType: req.body.vulnerabilityType,
        projectName: req.body.projectName,
        description: req.body.description,
        status: req.body.status,
        severity: req.body.severity,
        assignedPerson: '623948cf631e2a0366cff2db',
        assigner: '623a7797112eee9b3211cbd2',
        Comment:[]

    }

    Vulnerability.create(newVulnerability, function(err, vulnerability) {
        if (err) {
            console.log("Error creating vulnerability");
            response.status= process.env.HTTP_STATUS_INTERNAL_ERROR;
            response.message= err;
        }
        else {
            response.status = process.env.HTTP_STATUS_CREATED;
            response.message = vulnerability;
        }
        res.status(response.status).json(response.message);
        
    })
}

const deleteOneVulnerability = (req, res) => {

    console.log("Delete One Vulnerability Controller called");
    const vulnerabilityId= req.params.vulnerabilityId;
    const response = initResponse()
    //check if gameId is valid
    if(!mongoose.isValidObjectId(vulnerabilityId)) {
            console.log("invalid Id");
            response.status = process.env.HTTP_STATUS_NOTFOUND;
            response.message = {message : "Invalid vulnerabilityId"}
            return res.status(response.status).json(response.message)
    }

    Vulnerability.findByIdAndDelete(vulnerabilityId).exec(function(err, deletedVulnerability) {
        if(err) {
            console.log("Error reading Vulnerability");
            response.status = process.env.HTTP_STATUS_INTERNAL_ERROR;
            response.message = err;

        } 
        else if(!deletedVulnerability) {
            console.log(" Vulnerability to delete not found");
            response.status = process.env.HTTP_STATUS_NOTFOUND;
                response.message = {"message": "Vulnerability ID not found"};
        }
        else {
                console.log("Found Vulnerability to delete");
                response.status = process.env.HTTP_STATUS_OK;
                response.message = deletedVulnerability;
        }

        return res.status(response.status).json(response.message);
        
        });
}


const updateOneVulnerability = function(req, res) {
    console.log("Update One Vulnerability Controller called.")
    vulnerabilityUpdate = function(req, res, vulnerability, response){

        vulnerability.vulnerabilityType = req.body.vulnerabilityType;
        vulnerability.projectName  = req.body.projectName;
        vulnerability.description = req.body.description;
        vulnerability.status = req.body.status;
        vulnerability.severity =  req.body.severity;
        vulnerability.assignedPerson =  '623948cf631e2a0366cff2db';
        vulnerability.assigner = '623a7797112eee9b3211cbd2',
        vulnerability.Comment = []

        _saveRefactory(res, vulnerability, response);
    }
    _updateVulnerability(req, res, vulnerabilityUpdate);
}

module.exports = {
    getOneVulnerability: getOneVulnerability,
    getAllVulnerabilities: getAllVulnerabilities,
    deleteOneVulnerability: deleteOneVulnerability,
    updateOneVulnerability: updateOneVulnerability,
    AddOneVulnerability: AddOneVulnerability,
    initResponse: initResponse,
    _saveRefactory : _saveRefactory
}