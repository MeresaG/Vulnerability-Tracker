const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const Person = mongoose.model(process.env.PERSON_MODEL);
const _helpers = require('../helpers/refactoringHelpers');
const inputValidation = require('../helpers/inputValidator')


const getPersons = function(req, res) {
    console.log("Person Controller");
    const response = _helpers.initResponse();
    Person.find().exec()
            .then((persons) => _helpers._handleSuccessResponse(persons, response))
            .catch((err) => _helpers._handleErrorResponse(err, response))
            .finally(() => _helpers._handleReturnResponse(res, response))
}

const getPerson = function(req, res, value) {
    console.log("Person Controller");
    const response = _helpers.initResponse();
    Person.findOne({"email" :value}).exec()
            .then( (person) => {return person._id})
            .catch((err) => _helpers._handleError(err, res, response))
            
            
}


const _createTokenAndSendResponse = function(person, result, res, response) {

    if(!result) {
        response.status = process.env.HTTP_STATUS_NOTFOUND;
        response.message = {"message" : "Email or Password is wrong"}
        return _helpers._handleReturnResponse(res, response);
    }


    //create and assign a token
    const token = jwt.sign({_id : person._id}, process.env.TOKEN_SECRET, {expiresIn:3600});
    res.header('auth-token', token);
    response.message = {
            id: person._id,
            userName: person.userName,
            email: person.email,
            roles: person.role,
            accessToken: token
    }
    console.log(response.message);
    return _helpers._handleReturnResponse(res, response);
}

const _handleIfPasswordExist = function(person, req, res, response) {
   
    if(!person) {
        response.status = process.env.HTTP_STATUS_NOTFOUND;
        response.message = {"message" : "Email or Password is wrong"}
        return _helpers._handleReturnResponse(res, response);
    }
    const password = person.password;
    bcrypt.compare(req.body.password, password)
            .then( (result) => _createTokenAndSendResponse(person, result, res, response))
            .catch( (err) => _helpers._handleError(err, res, response))

}


const _handleHashErrorAndCreateUser = function(req, res, err, hashPassword,response) {
   
    if(err) {
        return _helpers._handleError(err, res, response);
    }

     //create a new person
     const {email, userName, firstName, lastName, role} = req.body;
    
     const person = new Person ({
         email : email,
         userName: userName,
         firstName : firstName,
         lastName: lastName,
         role : role,
         password : hashPassword
     }) ;

     Person.create(person)
            .then( (createdPerson) => _helpers._handleSuccess(createdPerson, res, response))
            .catch( (err) => _helpers._handleError(err, res, response))
}

const _handleSaltErrorAndGenerateHash = function(req, res, err, salt, response) {

    if(err) {
       return  _helpers._handleError(err, res, response)
    }
    bcrypt.hash(req.body.password, salt, (err, hashPassword) => _handleHashErrorAndCreateUser(req, res, err, hashPassword,response));


}

const signupPerson = async function(req, res) {
    const response = _helpers.initResponse();
    delete req.body.passwordConfirm;
    const { error } = inputValidation.personValidation(req.body);

    if(error) {
        response.status = process.env.HTTP_STATUS_BAD_REQUEST
        response.message = error.details[0].message
        return _helpers._handleReturnResponse(res, response);
    }

    //check if the person is in the database
    try {
        const emailExists = await Person.findOne({email: req.body.email});

        if(emailExists) {
            response.status = process.env.HTTP_STATUS_BAD_REQUEST;
            response.message = {"message" : "Email already registered"}
            return _helpers._handleReturnResponse(res, response);
        }

        //hash the password
        bcrypt.genSalt(parseInt(process.env.SALT),(err, salt)  => _handleSaltErrorAndGenerateHash(req, res, err, salt, response));

    } catch(error) {
        return _helpers._handleError(error, res, response);    
    }
    
}

const signinPerson = async function(req, res) {
    const response = _helpers.initResponse();
    
    const { error } = inputValidation.loginValidation(req.body);
    if(error) {
        response.status = process.env.HTTP_STATUS_BAD_REQUEST
        response.message = error.details[0].message
        return _helpers._handleReturnResponse(res, response);
    }

    //check if the email is in the database
    Person.findOne({email: req.body.email}).exec()
            .then((data) => _handleIfPasswordExist(data, req, res, response))
            .catch((err) => _helpers._handleError(err, res, response))
    
    

}

module.exports = {
    signupPerson:signupPerson,
    signinPerson: signinPerson,
    getPerson: getPerson,
    getPersons:getPersons
}