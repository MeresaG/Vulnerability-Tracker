const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const Person = mongoose.model(process.env.PERSON_MODEL);
const _helpers = require('../helpers/refactoringHelpers');
const inputValidation = require('../helpers/inputValidator')


const getPerson = function(personId) {
    console.log("Get Person Controller called");
    const response = {
        status : process.env.HTTP_STATUS_OK,
        message: {}
    }
    if(mongoose.isValidObjectId(personId)) {
        console.log("Valid user Id");
        Person.findById(personId).exec(function(err, person) {
            if(err) {
                console.log("Error reading Person");
                response.status = process.env.HTTP_STATUS_INTERNAL_ERROR;
                response.message = err;    
            }
            if(person) {
                console.log("Found Person");
                response.status = process.env.HTTP_STATUS_OK;
                response.message = person.id; 
            }
            else {
                console.log("Person is null");
                response.status = process.env.process.env.HTTP_STATUS_NOTFOUND;
                response.message = {"message" : "Person with given Id not found"}
            }
            console.log(response.message);
            return response;
            });

    }
    else {
        response.status = process.env.HTTP_STATUS_NOTFOUND;
        response.message = {"message" : "Invalid user Id"}
        return response;
    }

}

const signupPerson = async function(req, res) {
    const response = _helpers.initResponse();

    const { error } = inputValidation.personValidation(req.body);
    if(error) {
        response.status = process.env.HTTP_STATUS_BAD_REQUEST
        response.message = error.details[0].message
        return res.status(response.status).json(response.message)
    }

    //check if the person is in the database
    const emailExists = await Person.findOne({email: req.body.email});
    if(emailExists) {
        response.status = process.env.HTTP_STATUS_BAD_REQUEST;
        response.message = {"message" : "Email already registered"}
        return res.status(response.status).json(response.message)
    }

    //hash the password
    const salt = await bcrypt.genSalt(10);
    const hashPassword = await bcrypt.hash(req.body.password, salt);

    //create a new person
    const {email, userName, firstName, lastName, role} = req.body;
    
    const person = new Person ({
        email : email,
        userName: userName,
        firstName : firstName,
        lastName: lastName,
        role : role,
        password : hashPassword
    }) ;
    try {
        
        const savePerson = await person.save();
        response.status = process.env.HTTP_STATUS_OK;
        response.message = savePerson._id;
        return res.status(response.status).json(response.message);


    } catch (error) {
        response.status = process.env.HTTP_STATUS_INTERNAL_ERROR;
        response.message = error
        return res.status(response.status).json(response.message);
    }
}

const signinPerson = async function(req, res) {
    const response = _helpers.initResponse();

    const { error } = inputValidation.loginValidation(req.body);
    if(error) {
        response.status = process.env.HTTP_STATUS_BAD_REQUEST
        response.message = error.details[0].message
        return res.status(response.status).json(response.message)
    }

    //check if the email is in the database
    const person = await Person.findOne({email: req.body.email});
    if(!person) {
        response.status = process.env.HTTP_STATUS_NOTFOUND;
        response.message = {"message" : "Email or Password is wrong"}
        return res.status(response.status).json(response.message)
    }

    //check if password is valid
    const validPassword = await bcrypt.compare(req.body.password, person.password);
    if(!validPassword) {
        response.status = process.env.HTTP_STATUS_NOTFOUND;
        response.message = {"message" : "Email or Password is wrong"}
        return res.status(response.status).json(response.message)
    } 

    //create and assign a token
    const token = jwt.sign({_id : person._id}, process.env.TOKEN_SECRET);
    res.header('auth-token', token);
    response.status = process.env.HTTP_STATUS_OK;
    response.message = person
    return res.status(response.status).json(response.message)

}

module.exports = {
    getPerson : getPerson,
    signupPerson:signupPerson,
    signinPerson: signinPerson
}