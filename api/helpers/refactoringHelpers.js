const mongoose = require('mongoose');

const initResponse = function() {
    const response = {
        status : process.env.HTTP_STATUS_OK,
        message : {} 
    }
    return response;
}

const _handleError = function (err, res, response) {

    response.status = process.env.HTTP_STATUS_INTERNAL_ERROR;
    response.message = err;
    return _handleReturnResponse(res, response)
}

const _handleSuccess = function(data, res, response) {
    response.status = process.env.HTTP_STATUS_OK;
    response.message = data;
    return _handleReturnResponse(res, response)
}

const _handleReturnResponse = function(res, response) {
    return res.status(response.status).json(response.message)
}


const _checkResponseRefactor = function(err, req, res, result, subDocument, methodCallBack, response, commentId=false) {

    if(err) {
        console.log("Error reading vulnerability");
        response.status = process.env.HTTP_STATUS_INTERNAL_ERROR;
        response.message = err;

    } 
    else if(!result) {
        console.log("vulnerability is null");
        response.status = process.env.HTTP_STATUS_NOTFOUND;
        response.message = {message : "vulnerability with given Id not found"};
     }
    if(result) {
        if(methodCallBack) {
            return methodCallBack(req, res, result, response);
        }
        else {
            response.status = process.env.HTTP_STATUS_CREATED;
            if(subDocument) {
                response.message = commentId? result.comment.id(commentId):result.comment;
            }else {
                response.message = result;
            }
            
            return res.status(response.status).json(response.message);
        }
    }
    else {
        return res.status(response.status).json(response.message);
    } 

}

const _saveRefactory = function(res, documentToUpdate, response) {
    //(err, updatedDcoument) => _checkResponseRefactor(err, res, result, subDocument, methodCallBack, response)
    documentToUpdate.save((err, updatedDcoument) => _checkResponseRefactor(err, false, res, updatedDcoument, false, false, response));
}

const _checkObjectIdRefactor = function(res, vulnerabilityId, commentId, response) {

    if(!commentId) {
        if(!(mongoose.isValidObjectId(vulnerabilityId))) {
            console.log("invalid vulnerabilityId");
            response.status = process.env.HTTP_STATUS_NOTFOUND;
            response.message = {message : "Invalid vulnerabilityId"}
            return res.status(response.status).json(response.message)
        }
    } else if(!(mongoose.isValidObjectId(vulnerabilityId) && mongoose.isValidObjectId(commentId))) {
        console.log("invalid vulnerability Id or Comment Id are invalid");
        response.status = process.env.HTTP_STATUS_NOTFOUND;
        response.message = {message : "Invalid vulnerabilityId or commentId"}
        return res.status(response.status).json(response.message)
    }


}

const _findByRefactory = function(req, res, collection, vulnerabilityId, subDocument, response, methodCallBack) {

    
    collection.findById(vulnerabilityId).select(subDocument).exec((err, vulnerability) => _checkResponseRefactor(err, req, res, vulnerability, false, methodCallBack, response));

}

module.exports = {
    initResponse:initResponse,
    _checkResponseRefactor:_checkResponseRefactor,
    _saveRefactory:_saveRefactory,
    _checkObjectIdRefactor:_checkObjectIdRefactor,
    _findByRefactory:_findByRefactory,
    _handleError: _handleError,
    _handleSuccess: _handleSuccess,
    _handleReturnResponse:_handleReturnResponse

}