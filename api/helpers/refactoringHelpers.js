const mongoose = require('mongoose');

const initResponse = function() {
    const response = {
        status : process.env.HTTP_STATUS_OK,
        message : {} 
    }
    return response;
}

const _handleError = function (err, res, response) {

    response.status = process.env.HTTP_STATUS_INTERNAL_ERROR;
    response.message = err;
    return _handleReturnResponse(res, response)
}

const _handleSuccess = function(data, res, response) {
    response.status = process.env.HTTP_STATUS_OK;
    response.message = data;
    return _handleReturnResponse(res, response)
}

const _handleErrorResponse = function (err, response) {

    response.status = process.env.HTTP_STATUS_INTERNAL_ERROR;
    response.message = err;
   
}

const _handleNotFoundResponse = function (response) {

    response.status = process.env.HTTP_STATUS_NOTFOUND;
    response.message = response.message = {message : "Id not found"};;
   
}

const _handleSuccessResponse = function(data, response) {
    response.status = process.env.HTTP_STATUS_OK;
    response.message = data;
}



const _handleReturnResponse = function(res, response) {
    return res.status(response.status).json(response.message)
}

const _handleSuccessComment = function(req, res, result, subDocument, methodCallBack, response, commentId=false) {
 
    if(!result) {
        console.log("vulnerability is null");
        response.status = process.env.HTTP_STATUS_NOTFOUND;
        response.message = {message : "vulnerability with given Id not found"};
     }
    if(result) {
        if(methodCallBack) {
            return methodCallBack(req, res, result, response);
        }
        else {
            response.status = process.env.HTTP_STATUS_CREATED;
            if(subDocument) {
                response.message = commentId? result.comment.id(commentId):result.comment;
            }else {
                response.message = result;
            }
            
            return _handleReturnResponse(res, response);
        }
    }
    else {
        return _handleReturnResponse(res, response);
    } 


}


const _saveRefactory = function(res, documentToUpdate, response) {
    //(err, updatedDcoument) => _checkResponseRefactor(err, res, result, subDocument, methodCallBack, response)
    documentToUpdate.save()
                    .then((updatedDcoument) => _handleSuccessComment(false, res, updatedDcoument, false, false, response))
                    .catch((err) => _handleError(err, res, response))
    
}

const _checkObjectIdRefactor = function(res, vulnerabilityId, commentId, response) {

    if(!commentId) {
        if(!(mongoose.isValidObjectId(vulnerabilityId))) {
            console.log("invalid vulnerabilityId");
            response.status = process.env.HTTP_STATUS_NOTFOUND;
            response.message = {message : "Invalid vulnerabilityId"}
            return _handleReturnResponse(res, response)
        }
    } else if(!(mongoose.isValidObjectId(vulnerabilityId) && mongoose.isValidObjectId(commentId))) {
        console.log("invalid vulnerability Id or Comment Id are invalid");
        response.status = process.env.HTTP_STATUS_NOTFOUND;
        response.message = {message : "Invalid vulnerabilityId or commentId"}
        return _handleReturnResponse(res, response)
    }


}

const _findByRefactory = function(req, res, collection, vulnerabilityId, subDocument, response, methodCallBack) {

    collection.findById(vulnerabilityId).select(subDocument).exec()
                .then( (vulnerability) => _handleSuccessComment(req, res, vulnerability, false, methodCallBack, response))
                .catch((err) => _handleError(err, res, response))

}

module.exports = {
    initResponse:initResponse,
    _handleSuccessComment: _handleSuccessComment,
    _saveRefactory:_saveRefactory,
    _checkObjectIdRefactor:_checkObjectIdRefactor,
    _findByRefactory:_findByRefactory,
    _handleError: _handleError,
    _handleSuccess: _handleSuccess,
    _handleErrorResponse: _handleErrorResponse,
    _handleSuccessResponse: _handleSuccessResponse,
    _handleNotFoundResponse: _handleNotFoundResponse,
    _handleReturnResponse:_handleReturnResponse

}